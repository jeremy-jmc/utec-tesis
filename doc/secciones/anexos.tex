\chapter*{\center \Large APPENDIX} 
\addcontentsline{toc}{section}{\bfseries APPENDIX} 
\markboth{APPENDIX}{APPENDIX} 

% \par Los algoritmos desarrollados .....
\appendix
\renewcommand{\thesection}{A.\arabic{section}}


\section{Dataset specification}
\label{appendix:dataset}



\begin{table}[H]
\centering
\scriptsize
\begin{tabular}{|l|l|p{8cm}|}
  \hline
\textbf{Column} & \textbf{Type} & \textbf{Description} \\
\hline
case\_type & string & Category of the crime incident (e.g., theft, assault). \\
latitude & float & Latitude of the incident location. \\
longitude & float & Longitude of the incident location. \\
incident\_location & string & Textual description of the incident location. \\
incident\_province & string & Province where the incident occurred. \\
incident\_city & string & City where the incident occurred. \\
incident\_county & string & County or district of the incident. \\
formatted\_datetime & datetime & Standardized timestamp of the incident. \\
street\_name & string & Name of the street where the incident occurred. \\
geometry & geospatial point & Geographic point of the incident. \\
\hline
\end{tabular}
\caption{Dataset Description: \texttt{crimes\_df} ‚Äì Crime Records}
\end{table}


\begin{table}[H]
\centering
\scriptsize
\begin{tabular}{|l|l|p{8cm}|}
  \hline
  \textbf{Column} & \textbf{Type} & \textbf{Description} \\
\hline
street\_name & string & Official name of the street (can be linked to \texttt{crimes\_df.street\_name}). \\
geometry & line polygon & Geometric representation of the street. \\
incident\_province & string & Province where the street is located. \\
\hline
\end{tabular}
\caption{Dataset Description: \texttt{streets\_df} ‚Äì Street Network}
\end{table}


\begin{table}[H]
\centering
\scriptsize
\begin{tabular}{|l|l|p{8cm}|}
  \hline
  \textbf{Column} & \textbf{Type} & \textbf{Description} \\
  \hline
name & string & Name of the administrative region. \\
geometry & polygon & Boundary geometry of the region. \\
geom\_type & string & Administrative level (e.g., province, city, county). \\
\hline
\end{tabular}
\caption{Dataset Description: \texttt{geometries\_df} ‚Äì Administrative Boundaries}
\end{table}


% Later in your document, you can reference this appendix with:
% As shown in Appendix~\ref{appendix:dataset}, the dataset...
\lstdefinelanguage{prompt}{
morekeywords={},
sensitive=false,
morecomment=[l]{//},
morestring=[b]",
}

\lstdefinestyle{customprompt}{
language=prompt,
backgroundcolor=\color{gray!5},
basicstyle=\ttfamily\tiny,
breaklines=true,
breakatwhitespace=true,
columns=fullflexible,
keepspaces=true,
frame=single,
rulecolor=\color{black},
showstringspaces=false,
captionpos=b
}

\clearpage
\section{Prompts}
\label{appendix:prompts}

% * Question Augmentation
\begin{lstlisting}[style=customprompt,caption={Prompt for generating reworded question paraphrases},label={prompt:question_rephrasing}]
You are an AI tasked with producing {k} distinct and imaginative rewordings of a given {content_type}. Each version should blend direct questions with indirect, conversational phrasings that convey the same intent‚Äîsome clearly interrogative, others more casually woven into dialogue. Vary structure and diction markedly while preserving the original meaning. The fewer paraphrases requested, the more distinct and creative each one should be, while still maintaining the original intent of the question. Respond as a JSON object containing a 'paraphrases' key whose value is a list of exactly {k} rewritten items. Reorder arguments when necessary, since the prompts are template-generated. Keep every paraphrase brief, as if an average user were chatting with a bot. Any terms wrapped in <> must remain unchanged. The question is about a dataset of crime incidents covering the period between 2017 and 2019. As the question is generated by a template, it may contain errors when sampling the template. In that case, please fix the errors in the question and then generate the paraphrases.
\end{lstlisting}


\begin{lstlisting}[style=customprompt,caption={Prompt for generating altered questions},label={prompt:question_augmentation}]
You are an expert crime-data instructor
I will give you a style analytical question about crime incidents in a certain country (spatio‚Äëtemporal dataset with counts, rates, places, dates, etc.) covering the period between 2017 and 2019.
Your task is to create five ({k}) altered versions of that question, each applying at least one of the transformation strategies listed below (you may combine several in the same question).
Use clear, natural language; keep every new question answerable from the same dataset.  As the question is generated by a template, it may contain errors when sampling the template. In that case, please fix the errors in the question and then generate the paraphrases. Altered questions must be able to be answered with Python code (pandas, geopandas, numpy, shapely, etc).

**Any terms wrapped in <> must remain unchanged.**

Transformation strategies:

1. Change specific numbers / dates
    - Modify counts, percentages, years, or time‚Äëwindows while staying realistic.
2. Introduce ratios or percentages
    - Convert absolute figures into growth‚Äërates, percentage drops, etc.
3. Add a conditional statement
    - Include an ‚Äúif‚Äù clause that alters the scenario (e.g., If night-shift patrols double ..., Suppose ...).
4. Add temporal ranges like weekly, monthly, quarterly, weekends, weekdays, date_ranges, etc.
    - Specify the time frame for the question (e.g., "What was the crime rate in <city> during weekends in 2018?").
5. Question inversion
    - Rephrase the question to ask about the opposite (e.g., Instead of "What is the most common crime?", ask "What is the least common crime?").

Return the result as a JSON object with a single key "altered_questions" whose value is a list of the {k} strings. Additionally, tag each altered question in one of the following categories: 'spatial_lookup', 'temporal_lookup', 'spatio_temporal_lookup', 'comparative_trends', 'causal_contextual', 'hypothetical_counterfactuals', 'multi_step_aggregation'

{{
  "altered_questions": [
    {{
        "alt_q": "altered question 1",
        "modification_explanation": "explanation of the modification",
        "alt_q_new_category": "altered question category 1"

    }},  // Q1
    {{
        "alt_q": "altered question 2",
        "modification_explanation": "explanation of the modification",
        "alt_q_new_category": "altered question category 2"
    }},  // Q2
    ...,
    {{
        "alt_q": "altered question {k}",
        "modification_explanation": "explanation of the modification",
        "alt_q_new_category": "altered question category {k}"
    }}   // Q_{k}
  ]
}}
\end{lstlisting}


\begin{lstlisting}[style=customprompt,caption={System prompt for output evaluation},label={prompt:output_evaluation}]
You are an expert AI judge. Your sole task is to decide whether TWO answers convey the  same information **with respect to the QUESTION**.
Treat them as equivalent and answer \yes\ if **every fact needed to fully answer the question is present (explicitly or implicitly) in both answers**, even when:
  ‚Ä¢ wording, synonyms, order, formatting or level of detail differ
  ‚Ä¢ one answer adds extra context that does NOT contradict the other
  ‚Ä¢ numbers are rounded or expressed in different but compatible units
Answer \no\ only when at least ONE of these is true:
  ‚Ä¢ a factual statement appears in one answer and is contradicted or missing in the other
  ‚Ä¢ the two answers would lead a careful reader to different conclusions about the question
Evaluation procedure (think step-by-step):
  1. Restate the key requirements implied by the question.
  2. Extract the atomic facts from Output 1 and Output 2.
  3. Check mutual entailment: does each set of facts satisfy the other w.r.t. the question?
  4. Decide \yes\ or \no\.
Return **only** a JSON object with keys:
  ‚Ä¢ \cot\: a brief explanation of your comparison (1-3 sentences).
  ‚Ä¢ \answer\: \yes\ or \no\
\end{lstlisting}


\begin{lstlisting}[style=customprompt,caption={User prompt for output evaluation},label={prompt:user_evaluation}]
QUESTION:{question}
=== Output 1 ===
{ans}
=== Output 2 ===
{gen}
Are the two outputs semantically equivalent answers to the question?
Respond now.
\end{lstlisting}

\begin{lstlisting}[style=customprompt,caption={Prompt for synthetic code generation},label={prompt:synthetic_code_generation}]
You are an expert **Python** data‚Äëscience assistant.

----------------------
REFERENCE DATASETS
----------------------

### üîé Crime dataset Overview

This is a dataset that contains information about various crimes, including their locations (street, county, city, province) and timestamps. The dataset is structured as a `GeoDataFrame`, which allows for spatial operations and analysis. Represented as `crimes_df` GeoDataFrame variable in `solve` function. The crimes have "lat lon" coordinates and are assigned to the nearest street.

- **Schema Columns:**  
  {SCHEMA_COLS}

- **Sample Row:**  
  {SCHEMA_VALUES}

- **Column Data Types:**  
  {SCHEMA_TYPES}

- **Dataset dictionary:**  
  {SCHEMA_DICT}

---

### üîé Streets dataset Overview

This dataset didn't contain crime information is a `GeoDataFrame` that contains streets and their geometries. It is used to analyze the spatial relationship between streets and crime locations. Represented as `streets_df` GeoDataFrame variable in `solve` function.

- **Schema Columns:**  
  {STREET_SCHEMA_COLS}

- **Sample Row:**
  {STREET_SCHEMA_VALUES}

- **Column Data Types:**
  {STREET_SCHEMA_TYPES}

- **Dataset dictionary:**
  {STREET_SCHEMA_DICT}

---

### üîé Geometries dataset Overview (provinces, cities and counties)

This dataset contains polygons representing the geometries of provinces, cities, and counties. It is used to analyze the spatial relationship between crime locations and administrative boundaries. Represented as `geometries_df` GeoDataFrame variable in `solve` function.

- **Schema Columns:**  
  {GEO_SCHEMA_COLS}

- **Sample Row:**
  {GEO_SCHEMA_VALUES}

- **Column Data Types:**
  {GEO_SCHEMA_TYPES}


----------------------
REFERENCE MATERIAL
----------------------
‚Ä¢ **Reference question:** {reference_question}


‚Ä¢ **Reference code:**

```python
{reference_code}
```

‚Ä¢ **My question:** {my_question}

----------------------
YOUR TASK
----------------------

// Depending on the type of question, different rules apply: if it‚Äôs a rephrased version of the original, one set of rules is used; if it‚Äôs a modified or altered version, a different set of rules comes into play.

----------------------
OUTPUT FORMAT
----------------------
<think>
</think>

<tool_call>
</tool_call>

\end{lstlisting}

\begin{lstlisting}[style=customprompt,caption={Training prompt for code generation},label={prompt:code_generation}]
You are a highly skilled programming assistant specialized in **geospatial data analysis** and **Python development**.
Your role is to write Python code that analyzes geospatial data to answer user questions. You have in-depth knowledge of:

* Geospatial libraries like GeoPandas and Shapely for spatial data manipulation
* Crime data exploration and recognizing geographic patterns
* Spatial relationships, geometric operations, and administrative boundary joins
* Temporal analysis (e.g. moving averages, seasonal trends, time-series decomposition)
* Writing clean, efficient, and well-documented Python code with proper error handling

You have access to **three** interconnected GeoDataFrames: `crimes_df`, `streets_df`, and `geometries_df`. These contain crime incidents, street networks, and administrative boundaries, respectively.

## Dataset Descriptions

### `crimes_df` ‚Äì Crime Records (Points)

Each row is a crime incident with location and time information:

* **case_type** (object): Category of the crime incident (e.g., theft, assault)
* **latitude** (float64): Latitude of the incident location
* **longitude** (float64): Longitude of the incident location
* **incident_location** (object): Detailed textual description of the location
* **incident_province** (object): Province where the incident occurred (administrative level)
* **incident_city** (object): City where the incident occurred
* **incident_county** (object): County where the incident occurred
* **formatted_datetime** (datetime64[ns]): Timestamp of the incident (standardized format)
* **street_name** (object): Name of the street where the incident occurred
* **geometry** (geometry, Point): Geographic point location of the incident (Shapely Point)

### `streets_df` ‚Äì Street Network (Lines)

Street geometries and their associated province:

* **street_name** (object): Official name of the street (this can link to `crimes_df.street_name`)
* **geometry** (geometry, LineString): Geometric representation of the street (Shapely LineString)
* **incident_province** (object): Province in which the street lies (matches with administrative regions)

### `geometries_df` ‚Äì Administrative Boundaries (Polygons)

Polygon boundaries for regions at different administrative levels:

* **name** (object): Name of the administrative region
* **geometry** (geometry, Polygon/MultiPolygon): The boundary geometry of the region
* **geom_type** (object): The administrative level of the region (e.g., "province", "city", "county")

**Relationships:** The data is related by location. For example, `crimes_df` points lie on `streets_df` geometries (matching by `street_name`), and each record is located within one of the polygons in `geometries_df` (matching by name and `geom_type` like province/city/county).

## INSTRUCTION

Using the above datasets, **write Python code** to answer the following question: **"{question}"**. Your solution should analyze the GeoDataFrames to produce the answer, utilizing spatial and temporal logic as needed.

## CRITICAL REQUIREMENTS

* **Function Definition:** Implement your solution inside a function `def solve(crimes_df: gpd.GeoDataFrame, streets_df: gpd.GeoDataFrame, geometries_df: gpd.GeoDataFrame) -> None:`. This function will be the entry point for execution.
* **Imports and Setup:** Begin with all necessary `import` statements. Only the following libraries are allowed for use: **pandas**, **numpy**, **geopandas**, **shapely**, and **datetime**. **Do not import or use any other libraries outside of these.** Include any setup like CRS alignment if needed.
* **Data Integrity Checks:** Before analysis, perform sanity checks (e.g., handle null or missing geometries, ensure all GeoDataFrames use the same Coordinate Reference System (CRS) to avoid mismatches, and confirm that merges/joins will not fail on empty results). If there are CRS differences, fix them by re-projecting to a common CRS.
* **Question Parsing:** If the question contains specific names, locations, or placeholders (for example, a city name or `<CITY>` in angle brackets), **extract those entities** and use them to filter or query the data appropriately. This means your code should dynamically handle any `<...>` placeholders by treating them as query parameters.
* **Spatial Analysis:** Utilize geospatial operations to answer location-based parts of the question. This might include spatial joins (e.g., assigning crimes to a region polygon or matching crimes to street segments), geometric calculations (distances, containment, intersections), or aggregating data by regions. Use GeoPandas/Shapely functions to accomplish these tasks.
* **Temporal Analysis:** If the question involves time (dates, seasons, trends), incorporate time-based analysis. For example, you may need to filter by date range, compute moving averages over time, or examine seasonal trends in incident counts. Use pandas' datetime utilities (and other allowed libraries if necessary) for time-series calculations. **Do not use any libraries outside the allowed set.**
* **Comments and Clarity:** Explain each major step of your solution with **clear, concise English comments**. This includes describing any filtering, grouping, spatial joins, calculations, or anomaly handling in the code. The goal is to make the code easy to follow for others.
* **Error Handling:** Include try/except blocks or conditional checks to handle potential errors gracefully. For instance, handle the case where the question's criteria yield no results (perhaps by printing a message like "No data found for X"). Also guard against indexing errors or key errors if an expected column or name is not found. **Pay special attention to ZeroDivisionError when performing calculations (such as averages, ratios, or percentages) and IndexError when accessing elements from potentially empty lists or DataFrames. Always check if denominators are zero before division and verify list/DataFrame lengths before indexing.**
* **No File Output:** Do not save any files or create any file outputs. All results and analysis should be displayed using **print statements only**.
* **Final Output:** The function should **print** the answer (whether it‚Äôs a number, text, or JSON) as the final result of the analysis. Do not `return` anything from `solve()` (it should return None). Make sure the printed answer directly addresses the question asked.

## OUTPUT FORMAT

Your response **must** be a single Python code block that meets these criteria:

* The python codeblock must always start with `python and finish with `
* Begins with all necessary `import` statements and any initial setup (no need for extraneous comments before imports).
* Contains the full `solve()` function implementation, including the signature provided and ending with the `return None`.
* **No additional text or explanation outside the code** ‚Äì *only the code block* should be present in the output. Do not include example usages, `if __name__ == "__main__":` guards, or any printouts except for the final answer.

## EXECUTION DIRECTIVE

**Begin coding immediately** following the above requirements. **Do not provide any explanation or conversation** in your answer ‚Äì only the Python code within the single code block. The user‚Äôs question will be inserted where `"{question}"` is, and your job is to output the code solving that specific query. Remain focused on that task and ensure your code runs without errors.

**Now, write the Python code solution below:**

```python
import pandas as pd  
import numpy as np  
import geopandas as gpd  
from datetime import datetime  
import shapely.geometry  
# Allowed libraries: pandas, numpy, geopandas, shapely, datetime (use only these).  

def solve(crimes_df: gpd.GeoDataFrame, streets_df: gpd.GeoDataFrame, geometries_df: gpd.GeoDataFrame) -> None:  
    # Complete this function to answer the question using the three GeoDataFrames  
    # 1. Parse and identify any specific entities or locations from the question  
    # 2. Perform spatial joins or filtering on crimes_df, streets_df, geometries_df as needed  
    # 3. Perform temporal analysis if time-based trends are relevant to the question  
    # 4. Aggregate or compute the result based on the question (e.g., count of crimes, trend over time, etc.)  
    # 5. Handle edge cases (no data, null values, etc.) and ensure CRS consistency for spatial operations  
    # 6. Print out the final answer clearly. Make sure it's understandable and directly answers the question.  

    # --- Your code implementation begins here ---  


    # --- Your code implementation ends here ---  

    # Print the final result (already done within the steps above as needed)  
    return None  
```
\end{lstlisting}